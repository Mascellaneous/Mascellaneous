<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Country Battle</title>
  <link rel="stylesheet" href="country-battle-style.css">
</head>
<body>
  <div class="container">
    <h2>Country Battle</h2>
    <button id="dark-mode-toggle">‚òæ</button>
    <p>Configure the grid size, number of countries, speed, terrain, and boundary type, then start the battle simulation.</p>
    <div class="input-group">
      <label for="gridSize">Grid Size:</label>
      <input type="number" id="gridSize" min="10" max="100" value="30">
    </div>
    <p>Min: 10, Max: 100</p>
    <div class="input-group">
      <label for="numCountries">Countries:</label>
      <input type="number" id="numCountries" min="2" max="10" value="10">
    </div>
    <p>Min: 2, Max: 10</p>
    <div class="input-group">
      <label for="updateFrequency">Speed (updates/sec):</label>
      <input type="number" id="updateFrequency" min="1" max="20" value="20">
    </div>
    <p>Min: 1, Max: 20</p>
    <div class="input-group">
      <label for="boundaryType">Boundary:</label>
      <select id="boundaryType">
        <option value="toroidal">Toroidal</option>
        <option value="fixed">Fixed</option>
      </select>
    </div>
    <div class="terrain-controls">
      <h3 style="margin-bottom: 15px; text-align: center;">Terrain System</h3>
      <div class="input-group">
        <label for="mountainPercent">Mountain %:</label>
        <input type="number" id="mountainPercent" min="0" max="50" value="15">
      </div>
      <div class="input-group">
        <label for="waterPercent">Water %:</label>
        <input type="number" id="waterPercent" min="0" max="50" value="15">
      </div>
      <div class="input-group">
        <label for="desertPercent">Desert %:</label>
        <input type="number" id="desertPercent" min="0" max="30" value="5">
      </div>
      <div class="terrain-legend">
        <div class="terrain-legend-item">
          <div class="terrain-legend-color" style="background-color: #FFFFFF; border: 2px solid #ccc;"></div>
          <span>Plains (neutral)</span>
        </div>
        <div class="terrain-legend-item">
          <div class="terrain-legend-color" style="background-color: #8B4513;"></div>
          <span>Mountains (+defense)</span>
        </div>
        <div class="terrain-legend-item">
          <div class="terrain-legend-color" style="background-color: #4169E1;"></div>
          <span>Water (+attack)</span>
        </div>
        <div class="terrain-legend-item">
          <div class="terrain-legend-color" style="background-color: #000000;"></div>
          <span>Desert (impassable)</span>
        </div>
      </div>
    </div>
    <div class="display-controls">
      <h3 style="margin-bottom: 15px; text-align: center;">Display Options</h3>
      <div class="input-group">
        <label for="showCountries">Show Countries:</label>
        <input type="checkbox" id="showCountries" checked style="width: auto; margin-left: 10px;">
      </div>
      <div class="input-group">
        <label for="showTerrain">Show Terrain:</label>
        <input type="checkbox" id="showTerrain" checked style="width: auto; margin-left: 10px;">
      </div>
    </div>
    <!-- Natural Disaster Controls -->
    <div class="disaster-controls">
      <h3 style="margin-bottom: 15px; text-align: center;">Natural Disasters üå™Ô∏è</h3>
      <div class="input-group">
        <label for="enableDisasters">Enable Disasters:</label>
        <input type="checkbox" id="enableDisasters" style="width: auto; margin-left: 10px;">
      </div>
      <div id="active-disasters"></div>
    </div>
    <div class="bless-controls">
      <h3 style="margin-bottom: 15px; text-align: center;">Divine Interventions ‚ö°</h3>
      <div class="input-group">
        <label for="blessCountry">Target Country:</label>
        <select id="blessCountry">
          <option value="1">Country 1</option>
          <option value="2">Country 2</option>
          <option value="3">Country 3</option>
          <option value="4">Country 4</option>
          <option value="5">Country 5</option>
          <option value="6">Country 6</option>
          <option value="7">Country 7</option>
          <option value="8">Country 8</option>
          <option value="9">Country 9</option>
          <option value="10">Country 10</option>
        </select>
      </div>
      <div class="blessing-grid">
        <button class="blessing-button war" onclick="castBlessing('war')">
          ‚öîÔ∏è Blessing of War<br>
          <small>+50% attack for 10 rounds</small>
          <div class="blessing-cooldown" id="war-cooldown"></div>
        </button>
        <button class="blessing-button shield" onclick="castBlessing('shield')">
          üõ°Ô∏è Blessing of Protection<br>
          <small>+50% defense for 10 rounds</small>
          <div class="blessing-cooldown" id="shield-cooldown"></div>
        </button>
        <button class="blessing-button fortress" onclick="castBlessing('fortress')">
          üè∞ Blessing of Fortification<br>
          <small>Immune to conquest for 3 rounds</small>
          <div class="blessing-cooldown" id="fortress-cooldown"></div>
        </button>
      </div>
      <div id="active-blessings"></div>
    </div>
    <div class="button-group">
      <div class="main-controls">
        <button onclick="toggleSimulation()">Start</button>
        <button onclick="clearGrid()">Clear</button>
        <button onclick="randomizeGrid()">Randomize</button>
      </div>
      <div class="export-import-controls">
        <button onclick="exportMap()">Export Map</button>
        <button onclick="document.getElementById('import-file').click()">Import Map</button>
      </div>
    </div>
    <input type="file" id="import-file" accept=".json" onchange="importMap(event)">
    <div class="game-area">
      <canvas id="gameCanvas"></canvas>
      <div id="stats-panel">
        <div class="stats-item">Battles This Round: <span id="battles-count">0</span></div>
        <div id="country-stats"></div>
      </div>
    </div>
    <div id="status">Round: 0, Countries Remaining: 0</div>
    <div id="battle-log">
      <h3>Battle Log</h3>
      <div class="log-filters">
        <button class="filter-btn active" onclick="setLogFilter('all')">All</button>
        <button class="filter-btn" onclick="setLogFilter('important')">Important</button>
        <button class="filter-btn" onclick="setLogFilter('disasters')">Disasters</button>
        <button class="filter-btn" onclick="setLogFilter('blessings')">Blessings</button>
      </div>
      <div id="battle-log-content"></div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    let gridSize = parseInt(document.getElementById('gridSize').value);
    let numCountries = parseInt(document.getElementById('numCountries').value);
    let cellSize = 10;
    let grid = [];
    let terrain = [];
    let isRunning = false;
    let round = 0;
    let animationId = null;
    let updateFrequency = parseInt(document.getElementById('updateFrequency').value);
    let boundaryType = document.getElementById('boundaryType').value;
    let battlesThisRound = 0;
    let countryHighs = [];
    let countryLows = [];
    let battleLog = [];
    let currentLogFilter = 'all';
    let mountainPercent = 15;
    let waterPercent = 15;
    let desertPercent = 5;
    let showCountries = true;
    let showTerrain = true;
    let enableDisasters = false;
    
    // Blessing system
    let activeBlessings = [];
    let blessingCooldowns = {
      war: 0,
      shield: 0,
      fortress: 0
    };
    
    // Disaster system
    let activeDisasters = [];

    // Define colors for up to 10 countries
    const countryColors = [
      '#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF',
      '#00FFFF', '#FFA500', '#800080', '#008000', '#FFC0CB'
    ];

    // Terrain types
    const TERRAIN_PLAINS = 0;
    const TERRAIN_MOUNTAIN = 1;
    const TERRAIN_WATER = 2;
    const TERRAIN_DESERT = 3;

    const terrainColors = {
      [TERRAIN_PLAINS]: '#FFFFFF',
      [TERRAIN_MOUNTAIN]: '#8B4513',
      [TERRAIN_WATER]: '#4169E1',
      [TERRAIN_DESERT]: '#000000'
    };

    function resizeCanvas() {
      gridSize = Math.max(10, Math.min(100, parseInt(document.getElementById('gridSize').value)));
      numCountries = Math.max(2, Math.min(10, parseInt(document.getElementById('numCountries').value)));
      cellSize = Math.min(600 / gridSize, 10);
      canvas.width = gridSize * cellSize;
      canvas.height = gridSize * cellSize;
      initializeGrid();
      updateBlessCountryOptions();
      updateStats();
      drawGrid();
    }

    function initializeGrid() {
      grid = Array(gridSize).fill().map(() => Array(gridSize).fill(0));
      terrain = Array(gridSize).fill().map(() => Array(gridSize).fill(TERRAIN_PLAINS));
      round = 0;
      battlesThisRound = 0;
      countryHighs = Array(numCountries).fill(0);
      countryLows = Array(numCountries).fill(Infinity);
      battleLog = [];
      activeBlessings = [];
      activeDisasters = [];
      blessingCooldowns = { war: 0, shield: 0, fortress: 0 };
      updateBattleLog();
      updateActiveBlessings();
      updateActiveDisasters();
      updateBlessingCooldowns();
      generateTerrain();
    }

    function generateTerrain() {
      const totalCells = gridSize * gridSize;
      const mountainCells = Math.floor(totalCells * mountainPercent / 100);
      const waterCells = Math.floor(totalCells * waterPercent / 100);
      const desertCells = Math.floor(totalCells * desertPercent / 100);

      terrain = Array(gridSize).fill().map(() => Array(gridSize).fill(TERRAIN_PLAINS));
      generateTerrainBlobs(TERRAIN_MOUNTAIN, mountainCells);
      generateTerrainBlobs(TERRAIN_WATER, waterCells);
      generateTerrainBlobs(TERRAIN_DESERT, desertCells);
    }

    function generateTerrainBlobs(terrainType, targetCells) {
      let placedCells = 0;
      const maxAttempts = 50;
      
      while (placedCells < targetCells) {
        let blobSize = Math.min(
          Math.floor(Math.random() * 15) + 5,
          targetCells - placedCells
        );
        
        let startX, startY;
        let attempts = 0;
        do {
          startX = Math.floor(Math.random() * gridSize);
          startY = Math.floor(Math.random() * gridSize);
          attempts++;
        } while (terrain[startX][startY] !== TERRAIN_PLAINS && attempts < maxAttempts);
        
        if (attempts >= maxAttempts) break;
        
        const blobCells = [{x: startX, y: startY}];
        terrain[startX][startY] = terrainType;
        placedCells++;
        
        while (blobCells.length > 0 && placedCells < targetCells && blobSize > 1) {
          const currentCell = blobCells.splice(Math.floor(Math.random() * blobCells.length), 1)[0];
          
          const neighbors = getNeighbors(currentCell.x, currentCell.y);
          const validNeighbors = neighbors.filter(n => 
            n.x >= 0 && n.x < gridSize && 
            n.y >= 0 && n.y < gridSize && 
            terrain[n.x][n.y] === TERRAIN_PLAINS
          );
          
          if (validNeighbors.length > 0) {
            const expandTo = validNeighbors[Math.floor(Math.random() * validNeighbors.length)];
            terrain[expandTo.x][expandTo.y] = terrainType;
            blobCells.push(expandTo);
            placedCells++;
            blobSize--;
          }
        }
      }
    }

    function getNeighbors(x, y) {
      return [
        {x: x - 1, y: y}, {x: x + 1, y: y}, {x: x, y: y - 1}, {x: x, y: y + 1},
        {x: x - 1, y: y - 1}, {x: x - 1, y: y + 1}, {x: x + 1, y: y - 1}, {x: x + 1, y: y + 1}
      ];
    }

    function isTerrainOccupiable(terrainType) {
      return terrainType !== TERRAIN_DESERT;
    }

    function updateBlessCountryOptions() {
      const select = document.getElementById('blessCountry');
      select.innerHTML = '';
      for (let i = 1; i <= numCountries; i++) {
        const option = document.createElement('option');
        option.value = i;
        option.textContent = `Country ${i}`;
        select.appendChild(option);
      }
    }

    function castBlessing(type) {
      if (blessingCooldowns[type] > 0) {
        alert(`This blessing is on cooldown for ${blessingCooldowns[type]} more rounds!`);
        return;
      }

      const countryId = parseInt(document.getElementById('blessCountry').value);
      const countryStats = computeCountryStats();
      
      if (countryStats.counts[countryId - 1] === 0) {
        alert(`Country ${countryId} has been eliminated and cannot receive blessings!`);
        return;
      }

      let blessing = null;

      switch (type) {
        case 'war':
          blessing = {
            type: 'war',
            country: countryId,
            duration: 10,
            effect: 'attack',
            multiplier: 1.5,
            name: 'Blessing of War ‚öîÔ∏è'
          };
          blessingCooldowns.war = 15;
          break;
        
        case 'shield':
          blessing = {
            type: 'shield',
            country: countryId,
            duration: 10,
            effect: 'defense',
            multiplier: 1.5,
            name: 'Blessing of Protection üõ°Ô∏è'
          };
          blessingCooldowns.shield = 15;
          break;
        
        case 'fortress':
          blessing = {
            type: 'fortress',
            country: countryId,
            duration: 3,
            effect: 'immunity',
            multiplier: 1.0,
            name: 'Blessing of Fortification üè∞'
          };
          blessingCooldowns.fortress = 20;
          break;
      }

      if (blessing) {
        activeBlessings.push(blessing);
        addBattleLogEntry(`${blessing.name} cast on Country ${countryId}`, 'blessing');
        updateBattleLog();
        updateActiveBlessings();
        updateBlessingCooldowns();
      }
    }

    function addBattleLogEntry(message, type = 'normal') {
      battleLog.push({
        round: round,
        message: message,
        type: type,
        timestamp: Date.now()
      });
    }

    function setLogFilter(filter) {
      currentLogFilter = filter;
      
      // Update button states
      document.querySelectorAll('.filter-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      event.target.classList.add('active');
      
      updateBattleLog();
    }

    function updateActiveBlessings() {
      const container = document.getElementById('active-blessings');
      container.innerHTML = '';
      
      if (activeBlessings.length === 0) return;
      
      activeBlessings.forEach(blessing => {
        const div = document.createElement('div');
        div.className = 'active-blessing';
        let effectText = '';
        
        if (blessing.effect === 'immunity') {
          effectText = `Country ${blessing.country} is immune to conquest`;
        } else {
          const multiplierText = `+${Math.round((blessing.multiplier - 1) * 100)}%`;
          effectText = `Country ${blessing.country} has ${multiplierText} ${blessing.effect}`;
        }
        
        div.innerHTML = `
          <strong>${blessing.name}</strong><br>
          ${effectText}<br>
          <small>Duration: ${blessing.duration} rounds remaining</small>
        `;
        container.appendChild(div);
      });
    }

    function updateBlessingCooldowns() {
      Object.keys(blessingCooldowns).forEach(type => {
        const element = document.getElementById(`${type}-cooldown`);
        const button = element.parentElement;
        if (blessingCooldowns[type] > 0) {
          element.textContent = `${blessingCooldowns[type]}`;
          button.disabled = true;
          button.style.opacity = '0.6';
        } else {
          element.textContent = '';
          button.disabled = false;
          button.style.opacity = '1';
        }
      });
    }

    function getBlessingMultiplier(countryId, effectType) {
      let multiplier = 1.0;
      
      activeBlessings.forEach(blessing => {
        if (blessing.effect === effectType && blessing.country === countryId) {
          multiplier *= blessing.multiplier;
        }
      });

      activeDisasters.forEach(disaster => {
        if (disaster.effectType === 'defense' && disaster.country === countryId) {
          multiplier *= disaster.multiplier;
        }
      });      

      return multiplier;
    }

    function isCountryImmune(countryId) {
      return activeBlessings.some(blessing => 
        blessing.effect === 'immunity' && blessing.country === countryId
      );
    }

    function updateActiveDisasters() {
      const container = document.getElementById('active-disasters');
      container.innerHTML = '';

      if (activeDisasters.length === 0) return;

      activeDisasters.forEach(disaster => {
        const div = document.createElement('div');
        div.className = 'active-disaster';
        let effectText = `Country ${disaster.country} has -${Math.round((1 - disaster.multiplier) * 100)}% defense`;
        div.innerHTML = `
          <strong>${disaster.name}</strong><br>
          ${effectText}<br>
          <small>Duration: ${disaster.duration} rounds remaining</small>
        `;
        container.appendChild(div);
      });
    }

    function triggerDisasters() {
      if (!enableDisasters || Math.random() > 0.05) return; // 5% chance per round

      const disasterType = Math.random() < 0.5 ? 'unoccupation' : 'defense';

      if (disasterType === 'unoccupation') {
        const totalCells = gridSize * gridSize;
        const cellsToClearTarget = Math.floor(totalCells * 0.05); // 5% of cells

        // Collect all eligible cells (occupied and occupiable)
        const eligibleCells = [];
        for (let i = 0; i < gridSize; i++) {
          for (let j = 0; j < gridSize; j++) {
            if (grid[i][j] > 0 && isTerrainOccupiable(terrain[i][j])) {
              eligibleCells.push({ x: i, y: j, countryId: grid[i][j] });
            }
          }
        }

        // Determine how many cells to clear (min of target and available)
        const cellsToClear = Math.min(cellsToClearTarget, eligibleCells.length);
        if (cellsToClear === 0) {
          addBattleLogEntry(`Natural disaster found no occupied cells to clear`, 'disaster');
          updateBattleLog();
          return;
        }

        // Randomly shuffle and select cells to clear
        const shuffledCells = eligibleCells.sort(() => Math.random() - 0.5).slice(0, cellsToClear);
        const affectedCountries = {};

        // Clear selected cells
        shuffledCells.forEach(cell => {
          grid[cell.x][cell.y] = 0;
          affectedCountries[cell.countryId] = (affectedCountries[cell.countryId] || 0) + 1;
        });

        // Draw current grid state
        drawGrid();

        // Flash cleared cells
        ctx.fillStyle = '#FF4500'; // Orange flash
        shuffledCells.forEach(cell => {
          ctx.fillRect(cell.y * cellSize, cell.x * cellSize, cellSize - 1, cellSize - 1);
        });
        setTimeout(() => drawGrid(), 200); // Redraw after 200ms

        // Log affected countries and cell losses
        const logEntries = Object.entries(affectedCountries)
          .map(([countryId, count]) => `Country ${countryId} lost ${count} cell${count > 1 ? 's' : ''}`)
          .join(', ');
        addBattleLogEntry(`Natural disaster cleared ${cellsToClear} cells: ${logEntries}`, 'disaster');
        updateBattleLog();
        updateStats(); // Reflect cell losses in stats panel
      } else if (disasterType === 'defense') {
        const countryStats = computeCountryStats();
        const aliveCountries = countryStats.counts
          .map((count, index) => count > 0 ? index + 1 : null)
          .filter(id => id !== null);
        
        if (aliveCountries.length > 0) {
          const targetCountry = aliveCountries[Math.floor(Math.random() * aliveCountries.length)];
          activeDisasters.push({
            type: 'disaster',
            name: 'üå™Ô∏è Disaster Strike',
            country: targetCountry,
            duration: 10,
            effectType: 'defense',
            multiplier: 0.5
          });
          addBattleLogEntry(`Disaster weakened Country ${targetCountry}'s defense for 10 rounds`, 'disaster');
          updateBattleLog();
          updateActiveDisasters();
        }
      }
    }

    function randomizeGrid() {
      numCountries = Math.max(2, Math.min(10, parseInt(document.getElementById('numCountries').value)));
      
      generateTerrain();
      
      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          if (isTerrainOccupiable(terrain[i][j])) {
            grid[i][j] = Math.floor(Math.random() * numCountries) + 1;
          } else {
            grid[i][j] = 0;
          }
        }
      }
      
      round = 0;
      battlesThisRound = 0;
      countryHighs = Array(numCountries).fill(0);
      countryLows = Array(numCountries).fill(Infinity);
      battleLog = [];
      activeBlessings = [];
      activeDisasters = [];
      blessingCooldowns = { war: 0, shield: 0, fortress: 0 };
      updateBattleLog();
      updateActiveBlessings();
      updateActiveDisasters();
      updateBlessingCooldowns();
      updateBlessCountryOptions();
      updateStats();
      drawGrid();
    }

    function clearGrid() {
      initializeGrid();
      round = 0;
      battlesThisRound = 0;
      updateBlessCountryOptions();
      updateStats();
      if (isRunning) toggleSimulation();
      drawGrid();
    }

    function drawGrid() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          let cellColor = null;

          if (showTerrain && showCountries) {
            if (grid[i][j] === 0 || terrain[i][j] === TERRAIN_DESERT) {
              cellColor = terrainColors[terrain[i][j]];
            } else {
              cellColor = countryColors[grid[i][j] - 1];
            }
          } else if (showTerrain && !showCountries) {
            cellColor = terrainColors[terrain[i][j]];
          } else if (!showTerrain && showCountries) {
            if (grid[i][j] === 0) {
              cellColor = document.body.classList.contains('dark-mode') ? '#3a3a3a' : '#f8f9fa';
            } else {
              cellColor = countryColors[grid[i][j] - 1];
            }
          } else {
            cellColor = document.body.classList.contains('dark-mode') ? '#3a3a3a' : '#f8f9fa';
          }

          ctx.fillStyle = cellColor;
          ctx.fillRect(j * cellSize, i * cellSize, cellSize - 1, cellSize - 1);
        }
      }
    }

    function countNeighbors(x, y, countryId) {
      let count = 0;
      for (let i = -1; i <= 1; i++) {
        for (let j = -1; j <= 1; j++) {
          if (i === 0 && j === 0) continue;
          let nx = x + i;
          let ny = y + j;
          if (boundaryType === 'toroidal') {
            nx = (nx + gridSize) % gridSize;
            ny = (ny + gridSize) % gridSize;
            if (grid[nx][ny] === countryId) count++;
          } else if (boundaryType === 'fixed') {
            if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize) {
              if (grid[nx][ny] === countryId) count++;
            }
          }
        }
      }
      return count;
    }

    function computeCountryStats() {
      const counts = Array(numCountries).fill(0);
      const neighborSums = Array(numCountries).fill(0);
      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          if (grid[i][j] > 0) {
            const countryIndex = grid[i][j] - 1;
            counts[countryIndex]++;
            neighborSums[countryIndex] += countNeighbors(i, j, grid[i][j]);
          }
        }
      }
      const densityIndices = counts.map((count, index) => 
        count > 0 ? parseFloat((neighborSums[index] / count).toFixed(2)) : 0
      );
      return { counts, densityIndices };
    }

    function updateStats() {
      const stats = computeCountryStats();
      const counts = stats.counts || Array(numCountries).fill(0);
      const densityIndices = stats.densityIndices || Array(numCountries).fill(0);
      const totalCells = gridSize * gridSize;
      const remaining = counts.filter(count => count > 0).length;
      let statusText = `Round: ${round}, Countries Remaining: ${remaining}`;
      if (remaining <= 1) {
        statusText += remaining === 1 ? ' (One country dominates)' : ' (No countries remain)';
      }
      document.getElementById('status').textContent = statusText;

      counts.forEach((count, index) => {
        if (count > countryHighs[index]) {
          countryHighs[index] = count;
        }
        if (count > 0 && count < countryLows[index]) {
          countryLows[index] = count;
        }
      });

      const countryData = counts.map((count, index) => {
        const density = parseFloat(densityIndices[index] || 0);
        return {
          index,
          count,
          density,
          percentage: ((count / totalCells) * 100).toFixed(2),
          high: countryHighs[index],
          low: countryLows[index] === Infinity ? 'N/A' : countryLows[index],
          strength: count * (1 + density / 8)
        };
      }).filter(data => data.count > 0).sort((a, b) => 
        b.strength - a.strength || b.count - a.count || b.density - a.density || a.index - b.index
      );

      document.getElementById('battles-count').textContent = battlesThisRound;
      const countryStats = document.getElementById('country-stats');
      countryStats.innerHTML = '';
      countryData.forEach(data => {
        const div = document.createElement('div');
        div.className = 'stats-item';
        div.innerHTML = `
          <span class="color-box" style="background-color: ${countryColors[data.index]};"></span>
          Country ${data.index + 1}: ${data.count} cells (${data.percentage}%)
          <div class="country-stat">High: ${data.high} cells</div>
          <div class="country-stat">Low: ${data.low} cells</div>
          <div class="country-stat">Density: ${data.density.toFixed(2)}</div>
        `;
        countryStats.appendChild(div);
      });
    }

    function updateGrid() {
      const newGrid = JSON.parse(JSON.stringify(grid));
      const battles = [];
      const previousCounts = computeCountryStats().counts;

      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          if (grid[i][j] === 0 || !isTerrainOccupiable(terrain[i][j])) continue;
          for (let di = -1; di <= 1; di++) {
            for (let dj = -1; dj <= 1; dj++) {
              if (di === 0 && dj === 0) continue;
              let ni = i + di;
              let nj = j + dj;
              if (boundaryType === 'toroidal') {
                ni = (ni + gridSize) % gridSize;
                nj = (nj + gridSize) % gridSize;
              } else if (boundaryType === 'fixed') {
                if (ni < 0 || ni >= gridSize || nj < 0 || nj >= gridSize) continue;
              }
              
              // Can attack empty cells (grid value 0) or cells belonging to other countries
              if (isTerrainOccupiable(terrain[ni][nj]) && 
                  (grid[ni][nj] === 0 || (grid[ni][nj] !== grid[i][j] && grid[ni][nj] !== 0))) {
                battles.push({ attacker: { x: i, y: j, id: grid[i][j] }, defender: { x: ni, y: nj, id: grid[ni][nj] } });
              }
            }
          }
        }
      }

      const maxBattles = Math.floor(gridSize * gridSize * 0.05);
      const selectedBattles = battles.sort(() => Math.random() - 0.5).slice(0, maxBattles);
      battlesThisRound = selectedBattles.length;

      for (const battle of selectedBattles) {
        const attacker = battle.attacker;
        const defender = battle.defender;

        // Check if defender is immune (only applies to countries, not empty cells)
        if (defender.id !== 0 && isCountryImmune(defender.id)) {
          continue;
        }

        const attackerNeighbors = countNeighbors(attacker.x, attacker.y, attacker.id);
        let defenderNeighbors = 0;
        
        // Empty cells have no neighbors to help defend
        if (defender.id !== 0) {
          defenderNeighbors = countNeighbors(defender.x, defender.y, defender.id);
        }

        let attackerStrength = 0.3 + 0.15 * attackerNeighbors;
        let defenderStrength = 0.1 + 0.15 * defenderNeighbors; // Empty cells have very low base defense

        if (mountainPercent > 0 || waterPercent > 0) {
          const defenderTerrain = terrain[defender.x][defender.y];
          if (defenderTerrain === TERRAIN_MOUNTAIN) {
            defenderStrength *= 1.3;
          } else if (defenderTerrain === TERRAIN_WATER) {
            attackerStrength *= 1.3;
          }
        }

        // Apply blessing effects (only to countries, not empty cells)
        const attackBonus = getBlessingMultiplier(attacker.id, 'attack');
        let defenseBonus = 1.0;
        if (defender.id !== 0) {
          defenseBonus = getBlessingMultiplier(defender.id, 'defense');
        }

        attackerStrength *= attackBonus;
        defenderStrength *= defenseBonus;

        const totalStrength = attackerStrength + defenderStrength;
        const attackerWinProb = attackerStrength / totalStrength;

        if (Math.random() < attackerWinProb) {
          newGrid[defender.x][defender.y] = attacker.id;
        }
      }

      grid = newGrid; // Update grid with battle results
      round++;

      // Trigger disasters after battles
      triggerDisasters();

      // Update blessings and disasters
      activeBlessings = activeBlessings.filter(blessing => {
        blessing.duration--;
        if (blessing.duration <= 0) {
          addBattleLogEntry(`${blessing.name} on Country ${blessing.country} has expired`, 'blessing');
          return false;
        }
        return true;
      });

      activeDisasters = activeDisasters.filter(disaster => {
        disaster.duration--;
        if (disaster.duration <= 0) {
          addBattleLogEntry(`${disaster.name} on Country ${disaster.country} has ended`, 'disaster');
          return false;
        }
        return true;
      });

      Object.keys(blessingCooldowns).forEach(type => {
        if (blessingCooldowns[type] > 0) {
          blessingCooldowns[type]--;
        }
      });

      const currentCounts = computeCountryStats().counts;
      for (let i = 0; i < numCountries; i++) {
        if (previousCounts[i] > 0 && currentCounts[i] === 0) {
          addBattleLogEntry(`Country ${i + 1} eliminated`, 'important');
          activeBlessings = activeBlessings.filter(blessing => blessing.country !== (i + 1));
          activeDisasters = activeDisasters.filter(disaster => disaster.country !== (i + 1));
        }
      }

      updateStats();
      updateBattleLog();
      updateActiveBlessings();
      updateActiveDisasters();
      updateBlessingCooldowns();

      const remaining = currentCounts.filter(count => count > 0).length;
      if (remaining <= 1) {
        isRunning = false;
        document.querySelector('.main-controls button:nth-child(1)').textContent = 'Start';
        if (remaining === 1) {
          const winnerIndex = currentCounts.findIndex(count => count > 0);
          addBattleLogEntry(`Country ${winnerIndex + 1} wins the battle!`, 'important');
        }
      }

      drawGrid();
    }

    function updateBattleLog() {
      const logContent = document.getElementById('battle-log-content');
      
      let filteredLog = battleLog;
      
      if (currentLogFilter !== 'all') {
        filteredLog = battleLog.filter(entry => {
          switch (currentLogFilter) {
            case 'important':
              return entry.type === 'important';
            case 'disasters':
              return entry.type === 'disaster';
            case 'blessings':
              return entry.type === 'blessing';
            default:
              return true;
          }
        });
      }
      
      const displayLog = filteredLog.slice(-20).map(entry => 
        `Round ${entry.round}: ${entry.message}`
      );
      
      logContent.innerHTML = displayLog.join('<br>');
      logContent.scrollTop = logContent.scrollHeight;
    }

    function toggleSimulation() {
      isRunning = !isRunning;
      document.querySelector('.main-controls button:nth-child(1)').textContent = isRunning ? 'Pause' : 'Start';
      if (isRunning) {
        animate();
      } else {
        cancelAnimationFrame(animationId);
      }
    }

    function animate() {
      if (!isRunning) return;
      updateGrid();
      const interval = 1000 / updateFrequency;
      animationId = setTimeout(() => requestAnimationFrame(animate), interval);
    }

    function toggleDarkMode() {
      document.body.classList.toggle('dark-mode');
      document.getElementById('dark-mode-toggle').textContent = document.body.classList.contains('dark-mode') ? '‚òÄ' : '‚òæ';
      drawGrid();
      updateStats();
    }

    function exportMap() {
      const mapData = {
        gridSize, numCountries, grid, terrain, mountainPercent, waterPercent, desertPercent,
        boundaryType, round, battleLog, countryHighs, countryLows, showCountries, showTerrain,
        enableDisasters, activeBlessings, activeDisasters, blessingCooldowns
      };

      const dataStr = JSON.stringify(mapData, null, 2);
      const dataBlob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(dataBlob);
      
      const link = document.createElement('a');
      link.href = url;
      link.download = `country-battle-map-round-${round}.json`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }

    function importMap(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const mapData = JSON.parse(e.target.result);
          
          if (mapData.gridSize && mapData.grid && mapData.numCountries) {
            gridSize = mapData.gridSize;
            numCountries = mapData.numCountries;
            grid = mapData.grid;
            terrain = mapData.terrain || Array(gridSize).fill().map(() => Array(gridSize).fill(TERRAIN_PLAINS));
            mountainPercent = mapData.mountainPercent || 15;
            waterPercent = mapData.waterPercent || 15;
            desertPercent = mapData.desertPercent || 5;
            boundaryType = mapData.boundaryType || 'toroidal';
            round = mapData.round || 0;
            battleLog = mapData.battleLog || [];
            countryHighs = mapData.countryHighs || Array(numCountries).fill(0);
            countryLows = mapData.countryLows || Array(numCountries).fill(Infinity);
            showCountries = mapData.showCountries !== undefined ? mapData.showCountries : true;
            showTerrain = mapData.showTerrain !== undefined ? mapData.showTerrain : true;
            enableDisasters = mapData.enableDisasters || false;
            activeBlessings = mapData.activeBlessings || [];
            activeDisasters = mapData.activeDisasters || [];
            blessingCooldowns = mapData.blessingCooldowns || { war: 0, shield: 0, fortress: 0 };

            document.getElementById('gridSize').value = gridSize;
            document.getElementById('numCountries').value = numCountries;
            document.getElementById('boundaryType').value = boundaryType;
            document.getElementById('mountainPercent').value = mountainPercent;
            document.getElementById('waterPercent').value = waterPercent;
            document.getElementById('desertPercent').value = desertPercent;
            document.getElementById('showCountries').checked = showCountries;
            document.getElementById('showTerrain').checked = showTerrain;
            document.getElementById('enableDisasters').checked = enableDisasters;

            cellSize = Math.min(600 / gridSize, 10);
            canvas.width = gridSize * cellSize;
            canvas.height = gridSize * cellSize;
            
            if (isRunning) toggleSimulation();
            updateBlessCountryOptions();
            updateStats();
            updateBattleLog();
            updateActiveBlessings();
            updateActiveDisasters();
            updateBlessingCooldowns();
            drawGrid();
            
            alert('Map imported successfully!');
          } else {
            alert('Invalid map file format.');
          }
        } catch (error) {
          alert('Error importing map: ' + error.message);
        }
      };
      reader.readAsText(file);
      
      event.target.value = '';
    }

    // Event listeners
    document.getElementById('gridSize').addEventListener('change', resizeCanvas);
    document.getElementById('numCountries').addEventListener('change', resizeCanvas);
    document.getElementById('dark-mode-toggle').addEventListener('click', toggleDarkMode);
    document.getElementById('updateFrequency').addEventListener('input', () => {
      updateFrequency = Math.max(1, Math.min(20, parseInt(document.getElementById('updateFrequency').value)));
    });
    document.getElementById('boundaryType').addEventListener('change', () => {
      boundaryType = document.getElementById('boundaryType').value;
      if (isRunning) {
        toggleSimulation();
      }
    });

    document.getElementById('mountainPercent').addEventListener('change', (e) => {
      if (!isRunning) {
        mountainPercent = Math.max(0, Math.min(50, parseInt(e.target.value)));
        generateTerrain();
        randomizeGrid();
      } else {
        e.target.value = mountainPercent;
        alert('Cannot modify terrain while simulation is running!');
      }
    });

    document.getElementById('waterPercent').addEventListener('change', (e) => {
      if (!isRunning) {
        waterPercent = Math.max(0, Math.min(50, parseInt(e.target.value)));
        generateTerrain();
        randomizeGrid(); 
      } else {
        e.target.value = waterPercent;
        alert('Cannot modify terrain while simulation is running!');
      }
    });

    document.getElementById('desertPercent').addEventListener('change', (e) => {
      if (!isRunning) {
        desertPercent = Math.max(0, Math.min(30, parseInt(e.target.value)));
        generateTerrain();
        randomizeGrid();
      } else {
        e.target.value = desertPercent;
        alert('Cannot modify terrain while simulation is running!');
      }
    });

    document.getElementById('showCountries').addEventListener('change', (e) => {
      showCountries = e.target.checked;
      drawGrid();
    });

    document.getElementById('showTerrain').addEventListener('change', (e) => {
      showTerrain = e.target.checked;
      drawGrid();
    });

    document.getElementById('enableDisasters').addEventListener('change', (e) => {
      enableDisasters = e.target.checked;
      if (!enableDisasters) {
        activeDisasters = [];
        updateActiveDisasters();
        addBattleLogEntry('Natural disasters disabled', 'disaster');
        updateBattleLog();
      } else {
        addBattleLogEntry('Natural disasters enabled', 'disaster');
        updateBattleLog();
      }
    });

    canvas.addEventListener('click', (e) => {
      if (isRunning) return;
      const rect = canvas.getBoundingClientRect();
      const x = Math.floor((e.clientX - rect.left) / cellSize);
      const y = Math.floor((e.clientY - rect.top) / cellSize);
      
      if (isTerrainOccupiable(terrain[y][x])) {
        grid[y][x] = (grid[y][x] % numCountries) + 1;
        updateStats();
        drawGrid();
      }
    });

    resizeCanvas();
    randomizeGrid();
    toggleDarkMode();
  </script>
</body>
</html>